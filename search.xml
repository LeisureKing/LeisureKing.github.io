<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java中的enum类的使用</title>
      <link href="/2019/06/01/Java%E4%B8%AD%E7%9A%84enum%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/01/Java%E4%B8%AD%E7%9A%84enum%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<e>&gt;，而 E表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</e></p><a id="more"></a><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs undefined">public class Task4 &#123;<br>    public static void main(String[] args) &#123;<br>        System.out.println(Season.SPRING.toString());<br>        // valueof()匹配枚举类中相同字符串的成员<br>        System.out.println(Season.valueOf(&quot;SUMMER&quot;));// ordinal 返回序号<br>        System.out.println(Season.AUTUMN.ordinal());<br>    &#125;<br>&#125;<br><br>enum Season &#123;<br>    SPRING(&quot;春天&quot;, &quot;春风又绿江南岸&quot;), SUMMER(&quot;夏天&quot;, &quot;映日荷花别样红&quot;), <br>    AUTUMN(&quot;秋天&quot;, &quot;秋水共长天一色&quot;), WINTER(&quot;冬天&quot;, &quot;窗含西岭千秋雪&quot;);<br><br>    private String seasonName;<br>    private String seasonDesc;<br><br>    private Season(String seasonName, String seasonDesc) &#123;<br>        this.seasonDesc = seasonDesc;<br>        this.seasonName = seasonName;<br>    &#125;<br><br>    public String toString() &#123;<br>        return seasonName + &quot;:&quot; + seasonDesc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>SimpleDateFormat 格式化日期</title>
      <link href="/2019/05/31/SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/"/>
      <url>/2019/05/31/SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>白话文的讲：这些A——Z，a——z这些字母(不被单引号包围的)会被特殊处理替换为对应的日期时间，其他的字符串还是原样输出。<br>日期和时间模式(注意大小写，代表的含义是不同的)</p><p><img src="http://image.iamber.top/FleVj3Dr6BJNp9RW2wE9ypGfHfwM" alt=""><br><a id="more"></a></p><p>yyyy：年</p><p>MM：月</p><p>dd：日</p><p>hh：1~12小时制(1-12)</p><p>HH：24小时制(0-23)</p><p>mm：分</p><p>ss：秒</p><p>S：毫秒</p><p>E：星期几</p><p>D：一年中的第几天</p><p>F：一月中的第几个星期(会把这个月总共过的天数除以7)</p><p>w：一年中的第几个星期</p><p>W：一月中的第几星期(会根据实际情况来算)</p><p>a：上下午标识</p><p>k：和HH差不多，表示一天24小时制(1-24)。</p><p>K：和hh差不多，表示一天12小时制(0-11)。</p><p>z：表示时区</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">class MyTime2 implements MyDateTime &#123;<br>    <br>    @Override<br>    public String getDate() &#123;<br>        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);<br>        return format.format(new Date());<br>    &#125;<br><br>    @Override<br>    public String getDateTime() &#123;<br>        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.S&quot;);<br>        return format.format(new Date());<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>windows 超简单安装scrapy</title>
      <link href="/2019/01/20/windows-%E8%B6%85%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85scrapy/"/>
      <url>/2019/01/20/windows-%E8%B6%85%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85scrapy/</url>
      <content type="html"><![CDATA[<p>最近在学习爬虫，准备学习一波scrapy框架。打算先在自己电脑用一下爬虫框架，之后试一试服务器跑爬虫。</p><p>我百度了一下安装教程，挺长的，找了几个安装教程都出错了，而后发现了一个超级简单的方法。</p><p>先下载一个<code>Miniconda</code>  下载地址：<a href="https://conda.io/miniconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a> 选择合适的版本安装。</p><p>然后就一行命令<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install scrapy<br></code></pre></td></tr></table></figure></p><p>ok!然后就可以了！超级简单有木有呀！</p><p>验证安装是否成功，win+R 输入cmd 打开命令行窗口，输入下列代码出现版本信息就ok！<br><figure class="hljs highlight CMD"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD">scrapy -h<br></code></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 经验 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用阿里云服务器挖矿</title>
      <link href="/2018/12/26/%E5%88%A9%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%96%E7%9F%BF/"/>
      <url>/2018/12/26/%E5%88%A9%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%96%E7%9F%BF/</url>
      <content type="html"><![CDATA[<p>买了阿里云服务器的学生套餐好久但是一直没啥用，一直都是用来当作web项目存放器，感觉特别浪费。</p><p>后来突发奇想，想用服务器来挖矿，然后就找了一波相关知识。具体来说用服务器挖矿主要是用cpu，而cpu的话门罗币比较支持。我用的ubantu16.04版本。</p><p>挖矿前准备好的东西：<br>1、 交易账号<br>2、 钱包地址<br>3.、一台Linux服务器</p><p>一、申请一个钱包</p><p>这里申请一个在线钱包，打开网址（<a href="https://mymonero.com/#/）点击创建账户" target="_blank" rel="noopener">https://mymonero.com/#/）点击创建账户</a></p><p>然后把<code>Private Login Key</code>放入<code>Confirm your Private Login Key</code>中点击验证即可</p><a id="more"></a><p><img src="http://image.iamber.top//18-12-26/4474354.jpg" alt=""></p><p>需要保存 Private Login Key 和 出来的 address</p><p><img src="http://image.iamber.top//18-12-26/25192495.jpg" alt=""></p><p>二、安装挖矿软件</p><p>具体代码<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get -y install git<br><br>$ git <span class="hljs-built_in">clone</span> https://github.com/fireice-uk/xmr-stak-cpu.git<br><br>$ sudo apt-get -y install libmicrohttpd-dev libssl-dev cmake build-essential<br><br>$ <span class="hljs-built_in">cd</span> xmr-stak-cpu/<br><br>$ cmake -DHWLOC_ENABLE=OFF <br><br>$ make install<br></code></pre></td></tr></table></figure></p><p><img src="http://image.iamber.top//18-12-26/43913409.jpg" alt=""></p><p>得到上图结果表示基本安装成功</p><p>三、配置相关文件</p><p>进入bin目录</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> bin<br><br>$ ./xmr-stak-cpu<br></code></pre></td></tr></table></figure><p><img src="http://image.iamber.top//18-12-26/524436.jpg" alt=""><br>得到结果如上图</p><p>将红色框内容复制到config.txt中去，也就是将下图红色框内的东西替换。</p><p><img src="http://image.iamber.top//18-12-26/64559123.jpg" alt=""></p><p>先别急，还需要用到config.txt。在里面找到</p><p>“pool_address” : “pool.usxmrpool.com:3333”,</p><p>“wallet_address” : “”,</p><p>“pool_password” : “”,</p><p>第一个参数是矿池地址。推荐几个，找到合适的主机地址和端口号填入一个参数里面</p><p><a href="http://minexmr.com/#" target="_blank" rel="noopener">http://minexmr.com/#</a></p><p><a href="https://monerohash.com/" target="_blank" rel="noopener">https://monerohash.com/</a></p><p><a href="http://pool.monero.org/" target="_blank" rel="noopener">http://pool.monero.org/</a></p><p>第二个参数是钱包地址，之前讲过，直接放入其中就可以</p><p>第三个参数是密码，一般填个x就可以。填完保存退出。</p><p>四、 现在开始挖矿</p><p>进入挖矿软件的bin目录，运行代码就可以看到挖矿开始，同时放到了后台，不会随ssh断开停止进程。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nohup ./xmr-stak-cpu<br></code></pre></td></tr></table></figure><p><img src="http://image.iamber.top//18-12-26/36962576.jpg" alt=""></p><p>五、 查看收益</p><p>打开下面网址，在搜索框输入钱包地址就可以看到，不过需要等挖矿挖了好长一段时间才能看到。</p><p><a href="https://xmr.nanopool.org/" target="_blank" rel="noopener">https://xmr.nanopool.org/</a></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖矿 </tag>
            
            <tag> Linux </tag>
            
            <tag> 门罗币 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>翻译</title>
      <link href="/2018/12/26/%E7%BF%BB%E8%AF%91/"/>
      <url>/2018/12/26/%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>or fuzzy set theory provides a means to compute with words. It concentrates on the use of fuzzy values that capture the meaning of words, human reasoning and decision making, and provides a way of breaking through the computational burden of traditional expert systems.</p><p>.    Expert systems can neither learn nor improve themselves through experience. They are individually created and demand large efforts for their development. It can take from five to ten person-years to build even a moderate expert system. Machine learning can accelerate this process significantly and enhance the quality of knowledge by adding new rules or changing incorrect ones.</p><p>.    Artificial neural networks, inspired by biological neural networks, learn from historical cases and make it possible to generate rules automatically and thus avoid the tedious and expensive processes of knowledge acquisition, valida-tion and revision.</p><p>.    Integration of expert systems and ANNs, and fuzzy logic and ANNs improve the adaptability, fault tolerance and speed of knowledge-based systems.</p><p>Questions for review</p><p>1    Define intelligence. What is the intelligent behaviour of a machine?</p><p>2    Describe the Turing test for artificial intelligence and justify its validity from a modern standpoint.</p><p>3    Define artificial intelligence as a science. When was artificial intelligence born?</p><p>4    What are weak methods? Identify the main difficulties that led to the disillusion with AI in the early 1970s.</p><p>5    Define expert systems. What is the main difference between weak methods and the expert system technology?</p><p>6    List the common characteristics of early expert systems such as DENDRAL, MYCIN and PROSPECTOR.</p><p>7    What are the limitations of expert systems?</p><p>8    What are the differences between expert systems and artificial neural networks?</p><p>9    Why was the field of ANN reborn in the 1980s?</p><p>10    What are the premises on which fuzzy logic is based? When was fuzzy set theory introduced?</p><p>11    What are the main advantages of applying fuzzy logic in knowledge-based systems?</p><p>12    What are the benefits of integrating expert systems, fuzzy logic and neural computing?</p><p>22    INTRODUCTION TO KNOWLEDGE-BASED INTELLIGENT SYSTEMS</p><p>References</p><p>Barto, A.G., Sutton, R.S. and Anderson C.W. (1983). Neurolike adaptive elements that can solve difficult learning control problems, IEEE Transactions on Systems, Man and Cybernetics, SMC-13, pp. 834–846.</p><p>Boden, M.A. (1977). Artificial Intelligence and Natural Man. Basic Books, New York. Broomhead, D.S. and Lowe, D. (1988). Multivariable functional interpolation and</p><p>adaptive networks, Complex Systems, 2, 321–355.</p><p>Bryson, A.E. and Ho, Y.-C. (1969). Applied Optimal Control. Blaisdell, New York. Buchanan, B.G., Sutherland, G.L. and Feigenbaum, E.A. (1969). Heuristic DENDRAL:</p><p>a program for generating explanatory hypotheses in organic chemistry, Machine Intelligence 4, B. Meltzer, D. Michie and M. Swann, eds, Edinburgh University Press, Edinburgh, Scotland, pp. 209–254.</p><p>Cook, S.A. (1971). The complexity of theorem proving procedures, Proceedings of the Third Annual ACM Symposium on Theory of Computing, New York, pp. 151–158.</p><p>Cowan, J.D. (1990). Neural networks: the early days, Advances in Neural Information Processing Systems 2, D.S. Tourefzky, ed., San Mateo, CA: Morgan Kaufman, pp. 828–842.</p><p>Cox, E. (1999). The Fuzzy Systems Handbook: A Practitioner’s Guide to Building, Using, and Maintaining Fuzzy Systems, 2nd edn. Academic Press, San Diego, CA.</p><p>Duda, R., Gaschnig, J. and Hart, P. (1979). Model design in the PROSPECTOR consultant system for mineral exploration, Expert Systems in the Microelectronic Age, D. Michie, ed., Edinburgh University Press, Edinburgh, Scotland, pp. 153–167.</p><p>Durkin, J. (1994). Expert Systems Design and Development. Prentice Hall, Englewood Cliffs, NJ.</p><p>Feigenbaum, E.A., Buchanan, B.G. and Lederberg, J. (1971). On generality and problem solving: a case study using the DENDRAL program, Machine Intelligence 6, B. Meltzer and D. Michie, eds, Edinburgh University Press, Edinburgh, Scotland, pp. 165–190.</p><p>Fogel, D.B. (1995). Evolutionary Computation – Towards a New Philosophy of Machine Intelligence. IEEE Press, Piscataway, NJ.</p><p>Goldberg, D.E. (1989). Genetic Algorithms in Search, Optimisation and Machine Learning. Addison-Wesley Publishing Company, Reading, MA.</p><p>Greenblatt, R.D., Eastlake, D.E. and Crocker, S.D. (1967). The Greenblatt Chess Program, Proceedings of the Fall Joint Computer Conference, pp. 801–810.</p><p>Grossberg, S. (1980). How does a brain build a cognitive code?, Psychological Review, 87, pp. 1–51.</p><p>Holland, J.H. (1975). Adaptation in Natural and Artificial Systems. University of Michigan Press, Ann Arbor.</p><p>Holland, J.H. (1995). Hidden Order: How Adaptation Builds Complexity. Addison-Wesley, Reading, MA.</p><p>Hopfield, J.J. (1982). Neural networks and physical systems with emergent collective computational abilities, Proceedings of the National Academy of Sciences of the USA, 79, pp. 2554–2558.</p><p>Karp, R.M. (1972). Reducibility among combinatorial problems, Complexity of Computer Computations, R.E. Miller and J.W. Thatcher, eds, Plenum, New York, pp. 85–103.</p><p>Kohonen, T. (1982). Self-organized formation of topologically correct feature maps,</p><p>Biological Cybernetics, 43, pp. 59–69.</p><p>Kosko, B. (1993). Fuzzy Thinking: The New Science of Fuzzy Logic. Hyperion, New York.</p><p>REFERENCES    23</p><p>Kosko, B. (1997). Fuzzy Engineering. Prentice Hall, Upper Saddle River, NJ.</p><p>Koza, J.R. (1992). Genetic Programming: On the Programming of the Computers by Means of Natural Selection. MIT Press, Cambridge, MA.</p><p>Koza, J.R. (1994). Genetic Programming II: Automatic Discovery of Reusable Programs. MIT Press, Cambridge, MA.</p><p>LeCun, Y. (1988). A theoretical framework for back-propagation, Proceedings of the 1988 Connectionist Models Summer School, D. Touretzky, G. Hilton and T. Sejnowski, eds, Morgan Kaufmann, San Mateo, CA, pp. 21–28.</p><p>Lighthill, J. (1973). Artificial intelligence: a general survey, Artificial Intelligence: A Paper Symposium. J. Lighthill, N.S. Sutherland, R.M. Needham, H.C. Longuest-Higgins and D. Michie, eds, Science Research Council of Great Britain, London.</p><p>McCarthy, J. (1958). Programs with common sense, Proceedings of the Symposium on Mechanisation of Thought Processes, vol. 1, London, pp. 77–84.</p><p>McCulloch, W.S. and Pitts, W. (1943). A logical calculus of the ideas immanent in nervous activity, Bulletin of Mathematical Biophysics, vol. 5, pp. 115–137.</p><p>Medsker, L. and Leibowitz, J. (1994). Design and Development of Expert Systems and Neural Computing. Macmillan, New York.</p><p>Minsky, M.L. (1975). A framework for representing knowledge, The Psychology of Computer Vision, P. Winston, ed., McGraw-Hill, New York, pp. 211–277.</p><p>Minsky, M.L. and Papert, S.A. (1969). Perceptrons. MIT Press, Cambridge, MA. Negoita, C.V. (1985). Expert Systems and Fuzzy Systems. Benjamin/Cummings, Menlo</p><p>Park, CA.</p><p>Newell, A. and Simon, H.A. (1961). GPS, a program that simulates human thought, Lernende Automatten, H. Billing, ed., R. Oldenbourg, Munich, pp. 109–124.</p><p>Newell, A. and Simon, H.A. (1972). Human Problem Solving. Prentice Hall, Englewood Cliffs, NJ.</p><p>Omlin, C.W. and Giles, C.L. (1996). Rule revision with recurrent neural networks,</p><p>IEEE Transactions on Knowledge and Data Engineering, 8(1), 183–188.</p><p>Parker, D.B. (1987). Optimal algorithms for adaptive networks: second order back propagation, second order direct propagation, and second order Hebbian learning,</p><p>Proceedings of the IEEE 1st International Conference on Neural Networks, San Diego, CA, vol. 2, pp. 593–600.</p><p>Rechenberg, I. (1965). Cybernetic Solution Path of an Experimental Problem. Ministry of Aviation, Royal Aircraft Establishment, Library Translation No. 1122, August.</p><p>Rechenberg, I. (1973). Evolutionsstrategien – Optimierung Technischer Systeme Nach Prinzipien der Biologischen Information. Friedrich Frommann Verlag (Gu¨ nther Holzboog K.G.), Stuttgart–Bad Cannstatt.</p><p>Rosenblatt, F. (1962). Principles of Neurodynamics. Spartan, Chicago.</p><p>Rumelhart, D.E. and McClelland, J.L., eds (1986). Parallel Distributed Processing: Explorations in the Microstructures of Cognition. 2 vols, MIT Press, Cambridge, MA.</p><p>Samuel, A.L. (1959). Some studies in machine learning using the game of checkers,</p><p>IBM Journal of Research and Development, 3(3), 210–229.</p><p>Samuel, A.L. (1967). Some studies in machine learning using the game of checkers II – recent progress, IBM Journal of Research and Development, 11(6), 601–617.</p><p>Schwefel, H.-P. (1995). Evolution and Optimum Seeking. John Wiley, New York. Shannon, C.E. (1950). Programming a computer for playing chess, Philosophical</p><p>Magazine, 41(4), 256–275.</p><p>Shortliffe, E.H. (1976). MYCIN: Computer-Based Medical Consultations. Elsevier Press, New York.</p><p>24    INTRODUCTION TO KNOWLEDGE-BASED INTELLIGENT SYSTEMS</p><p>Turban, E. and Aronson, J.E. (2000). Decision Support Systems and Intelligent Systems,</p><p>6th edn. Prentice Hall, Englewood Cliffs, NJ.</p><p>Turing, A.M. (1950). Computing machinery and intelligence, Mind, 59, 433–460. van Melle, W. (1979). A domain independent production-rule system for consulta-</p><p>tion programs, Proceedings of the IJCAI 6, pp. 923–925.</p><p>van Melle, W., Shortliffe, E.H. and Buchanan B.G. (1981). EMYCIN: A domain-independent system that aids in constructing knowledge-based consultation programs, Machine Intelligence, Infotech State of the Art Report 9, no. 3.</p><p>Waterman, D.A. (1986). A Guide to Expert Systems. Addison-Wesley, Reading, MA. Yager, R.R. and Zadeh, L.A., eds (1994). Fuzzy Sets, Neural Networks and Soft Computing.</p><p>Van Nostrand Reinhold, New York.</p><p>Zadeh, L. (1965). Fuzzy sets, Information and Control, 8(3), 338–353.</p><p>Zahedi, F. (1993). Intelligent Systems for Business: Expert Systems with Neural Networks. Wadsworth, Belmont, CA.</p><p>Rule-based expert systems    2</p><p>In which we introduce the most popular choice for building knowledge-based systems: rule-based expert systems.</p><p>2.1    Introduction, or what is knowledge?</p><p>In the 1970s, it was finally accepted that to make a machine solve an intellectual problem one had to know the solution. In other words, one has to have knowledge, ‘know-how’, in some specific domain.</p><p>What is knowledge?</p><p>Knowledge is a theoretical or practical understanding of a subject or a domain. Knowledge is also the sum of what is currently known, and apparently knowl-edge is power. Those who possess knowledge are called experts. They are the most powerful and important people in their organisations. Any successful company has at least a few first-class experts and it cannot remain in business without them.</p><p>Who is generally acknowledged as an expert?</p><p>Anyone can be considered a domain expert if he or she has deep knowledge (of both facts and rules) and strong practical experience in a particular domain. The area of the domain may be limited. For example, experts in electrical machines may have only general knowledge about transformers, while experts in life insurance marketing might have limited understanding of a real estate insurance policy. In general, an expert is a skilful person who can do things other people cannot.</p><p>How do experts think?</p><p>The human mental process is internal, and it is too complex to be represented as an algorithm. However, most experts are capable of expressing their knowledge in the form of rules for problem solving. Consider a simple example. Imagine, you meet an alien! He wants to cross a road. Can you help him? You are an expert in crossing roads – you’ve been on this job for several years. Thus you are able to teach the alien. How would you do this?</p><p>26    RULE-BASED EXPERT SYSTEMS</p><p>You explain to the alien that he can cross the road safely when the traffic light is green, and he must stop when the traffic light is red. These are the basic rules. Your knowledge can be formulated as the following simple statements:</p><p>IF    the ‘traffic light’ is green</p><p>THEN    the action is go</p><p>IF    the ‘traffic light’ is red</p><p>THEN    the action is stop</p><p>These statements represented in the IF-THEN form are called production rules or just rules. The term ‘rule’ in AI, which is the most commonly used type of knowledge representation, can be defined as an IF-THEN structure that relates given information or facts in the IF part to some action in the THEN part. A rule provides some description of how to solve a problem. Rules are relatively easy to create and understand.</p><p>2.2    Rules as a knowledge representation technique</p><p>Any rule consists of two parts: the IF part, called the antecedent (premise or condition) and the THEN part called the consequent (conclusion or action).</p><p>The basic syntax of a rule is:</p><p>IF    <antecedent></antecedent></p><p>THEN    <consequent></consequent></p><p>In general, a rule can have multiple antecedents joined by the keywords AND (conjunction), OR (disjunction) or a combination of both. However, it is a good habit to avoid mixing conjunctions and disjunctions in the same rule.</p><p>IF    <antecedent 1=""></antecedent></p><p>AND    <antecedent 2=""></antecedent></p><p>.</p><p>.</p><p>.</p><p>AND    <antecedent n=""></antecedent></p><p>THEN    <consequent></consequent></p><p>IF    <antecedent 1=""></antecedent></p><p>OR    <antecedent 2=""></antecedent></p><p>.</p><p>.</p><p>.</p><p>OR    <antecedent n=""></antecedent></p><p>THEN    <consequent></consequent></p><p>RULES AS A KNOWLEDGE REPRESENTATION TECHNIQUE    27</p><p>The consequent of a rule can also have multiple clauses:</p><p>IF <antecedent> THEN <consequent 1=""></consequent></antecedent></p><consequent 2=""><p>.</p><p>.</p><p>.</p><consequent m=""><p>The antecedent of a rule incorporates two parts: an object (linguistic object) and its value. In our road crossing example, the linguistic object ‘traffic light’ can take either the value green or the value red. The object and its value are linked by an operator. The operator identifies the object and assigns the value. Operators such as is, are, is not, are not are used to assign a symbolic value to a linguistic object. But expert systems can also use mathematical operators to define an object as numerical and assign it to the numerical value. For example,</p><p>IF    ‘age of the customer’ &lt; 18</p><p>AND    ‘cash withdrawal’ &gt; 1000</p><p>THEN    ‘signature of the parent’ is required</p><p>Similar to a rule antecedent, a consequent combines an object and a value connected by an operator. The operator assigns the value to the linguistic object. In the road crossing example, if the value of traffic light is green, the first rule sets the linguistic object action to the value go. Numerical objects and even simple arithmetical expression can also be used in a rule consequent.</p><p>IF    ‘taxable income’ &gt; 16283</p><p>THEN    ‘Medicare levy’ ¼ ‘taxable income’    1.5 / 100</p><p>Rules can represent relations, recommendations, directives, strategies and heuristics (Durkin, 1994).</p><p>Relation</p><p>IF    the ‘fuel tank’ is empty</p><p>THEN    the car is dead</p><p>Recommendation</p><p>IF    the season is autumn</p><p>AND    the sky is cloudy</p><p>AND    the forecast is drizzle</p><p>THEN    the advice is ‘take an umbrella’</p><p>Directive</p><p>IF    the car is dead</p><p>AND    the ‘fuel tank’ is empty</p><p>THEN    the action is ‘refuel the car’</p><p>28    RULE-BASED EXPERT SYSTEMS</p><p>Strategy</p><p>IF    the car is dead</p><p>THEN    the action is ‘check the fuel tank’;</p><p>step1 is complete</p><p>IF    step1 is complete</p><p>AND    the ‘fuel tank’ is full</p><p>THEN    the action is ‘check the battery’;</p><p>step2 is complete</p><p>Heuristic</p><p>IF    the spill is liquid</p><p>AND    the ‘spill pH’ &lt; 6</p><p>AND    the ‘spill smell’ is vinegar</p><p>THEN    the ‘spill material’ is ‘acetic acid’</p><p>2.3    The main players in the expert system development team</p><p>As soon as knowledge is provided by a human expert, we can input it into a computer. We expect the computer to act as an intelligent assistant in some specific domain of expertise or to solve a problem that would otherwise have to be solved by an expert. We also would like the computer to be able to integrate new knowledge and to show its knowledge in a form that is easy to read and understand, and to deal with simple sentences in a natural language rather than an artificial programming language. Finally, we want our computer to explain how it reaches a particular conclusion. In other words, we have to build an expert system, a computer program capable of performing at the level of a human expert in a narrow problem area.</p><p>The most popular expert systems are rule-based systems. A great number have been built and successfully applied in such areas as business and engineering, medicine and geology, power systems and mining. A large number of companies produce and market software for rule-based expert system development – expert system shells for personal computers.</p><p>Expert system shells are becoming particularly popular for developing rule-based systems. Their main advantage is that the system builder can now concentrate on the knowledge itself rather than on learning a programming language.</p><p>What is an expert system shell?</p><p>An expert system shell can be considered as an expert system with the knowledge removed. Therefore, all the user has to do is to add the knowledge in the form of rules and provide relevant data to solve a problem.</p><p>Let us now look at who is needed to develop an expert system and what skills are needed.</p><p>In general, there are five members of the expert system development team: the domain expert, the knowledge engineer, the programmer, the project</p><p>THE MAIN PLAYERS IN THE EXPERT SYSTEM DEVELOPMENT TEAM    29</p><p>Figure 2.1    The main players of the expert system development team</p><p>manager and the end-user. The success of their expert system entirely depends on how well the members work together. The basic relations in the development team are summarised in Figure 2.1.</p><p>The domain expert is a knowledgeable and skilled person capable of solving problems in a specific area or domain. This person has the greatest expertise in a given domain. This expertise is to be captured in the expert system. Therefore, the expert must be able to communicate his or her knowledge, be willing to participate in the expert system development and commit a substantial amount of time to the project. The domain expert is the most important player in the expert system development team.</p><p>The knowledge engineer is someone who is capable of designing, building and testing an expert system. This person is responsible for selecting an appropriate task for the expert system. He or she interviews the domain expert to find out how a particular problem is solved. Through interaction with the expert, the knowledge engineer establishes what reasoning methods the expert uses to handle facts and rules and decides how to represent them in the expert system. The knowledge engineer then chooses some development software or an expert system shell, or looks at programming languages for encoding the knowledge (and sometimes encodes it himself). And finally, the knowledge engineer is responsible for testing, revising and integrating the expert system into the workplace. Thus, the knowledge engineer is committed to the project from the initial design stage to the final delivery of the expert system, and even after the project is completed, he or she may also be involved in maintaining the system.</p><p>The programmer is the person responsible for the actual programming, describing the domain knowledge in terms that a computer can understand. The programmer needs to have skills in symbolic programming in such AI</p><p>30    RULE-BASED EXPERT SYSTEMS</p><p>languages as LISP, Prolog and OPS5 and also some experience in the application of different types of expert system shells. In addition, the programmer should know conventional programming languages like C, Pascal, FORTRAN and Basic. If an expert system shell is used, the knowledge engineer can easily encode the knowledge into the expert system and thus eliminate the need for the program-mer. However, if a shell cannot be used, a programmer must develop the knowledge and data representation structures (knowledge base and database), control structure (inference engine) and dialogue structure (user interface). The programmer may also be involved in testing the expert system.</p><p>The project manager is the leader of the expert system development team, responsible for keeping the project on track. He or she makes sure that all deliverables and milestones are met, interacts with the expert, knowledge engineer, programmer and end-user.</p><p>The end-user, often called just the user, is a person who uses the expert system when it is developed. The user might be an analytical chemist determin-ing the molecular structure of soil from Mars (Feigenbaum et al., 1971), a junior doctor diagnosing an infectious blood disease (Shortliffe, 1976), an exploration geologist trying to discover a new mineral deposit (Duda et al., 1979), or a power system operator needing advice in an emergency (Negnevitsky, 1996). Each of these users of expert systems has different needs, which the system must meet: the system’s final acceptance will depend on the user’s satisfaction. The user must not only be confident in the expert system performance but also feel comfortable using it. Therefore, the design of the user interface of the expert system is also vital for the project’s success; the end-user’s contribution here can be crucial.</p><p>The development of an expert system can be started when all five players have joined the team. However, many expert systems are now developed on personal computers using expert system shells. This can eliminate the need for the programmer and also might reduce the role of the knowledge engineer. For small expert systems, the project manager, knowledge engineer, programmer and even the expert could be the same person. But all team players are required when large expert systems are developed.</p><p>2.4    Structure of a rule-based expert system</p><p>In the early 1970s, Newell and Simon from Carnegie-Mellon University proposed a production system model, the foundation of the modern rule-based expert systems (Newell and Simon, 1972). The production model is based on the idea that humans solve problems by applying their knowledge (expressed as produc-tion rules) to a given problem represented by problem-specific information. The production rules are stored in the long-term memory and the problem-specific information or facts in the short-term memory. The production system model and the basic structure of a rule-based expert system are shown in Figure 2.2.</p><p>A rule-based expert system has five components: the knowledge base, the database, the inference engine, the explanation facilities, and the user interface.</p></consequent></consequent>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖矿 </tag>
            
            <tag> Linux </tag>
            
            <tag> 门罗币 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分享一款自制的小软件</title>
      <link href="/2018/08/29/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E8%87%AA%E5%88%B6%E7%9A%84%E5%B0%8F%E8%BD%AF%E4%BB%B6/"/>
      <url>/2018/08/29/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E8%87%AA%E5%88%B6%E7%9A%84%E5%B0%8F%E8%BD%AF%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="分享一款时钟软件，自我感觉比较好看。搭配win10效果不错。"><a href="#分享一款时钟软件，自我感觉比较好看。搭配win10效果不错。" class="headerlink" title="分享一款时钟软件，自我感觉比较好看。搭配win10效果不错。"></a>分享一款时钟软件，自我感觉比较好看。搭配win10效果不错。</h2><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://image.iamber.top//18-10-20/55755888.jpg" alt="展示"></p><a id="more"></a><p>如果你喜欢隐藏下面的任务栏，这款软件就很不错，简洁美观。特别是这款软件内存小，而且可以搭配 <code>wallpaper engine</code> 使用效果特别不错。</p><p>这款软件没有做开机自启动，当时想着自己用，没必要这么麻烦。如果想要开机自启动的话，在Windows文件管理器中输入<code>%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup</code>可以打开一个文件夹，把软件或者快捷方式放到里面就可以了。修改注册表的方法就不推荐了。</p><p>有想要源码的可以私聊我 QQ：441169995。</p><h2 id="百度网盘："><a href="#百度网盘：" class="headerlink" title="百度网盘："></a>百度网盘：</h2><p>链接：<a href="https://pan.baidu.com/s/1RDatufeJcoBKnKdEF3iQnQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1RDatufeJcoBKnKdEF3iQnQ</a><br>密码：t422</p>]]></content>
      
      <categories>
          
          <category> 资源 </category>
          
          <category> 实用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 时钟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试</title>
      <link href="/2018/08/28/myblog/"/>
      <url>/2018/08/28/myblog/</url>
      <content type="html"><![CDATA[<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><img src="http://image.iamber.top//18-10-20/93949912.jpg" alt="测试"><br><a id="more"></a><br><a href="https://baidu.com" target="_blank" rel="noopener">baidu</a></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">py</span></span>&#123;<br>    syso();   <br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>康宁老杀头鬼</td><td>15</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/25/hello-world/"/>
      <url>/2018/08/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="一条悠闲的咸鱼"><a href="#一条悠闲的咸鱼" class="headerlink" title="一条悠闲的咸鱼"></a>一条悠闲的咸鱼</h1><p>有问题可以用QQ联系我</p><p>QQ: 441169995</p>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
